using System.Text;
using Google.Protobuf;
using Google.Protobuf.Compiler;
using Google.Protobuf.Reflection;
using TcHaxx.ProtocGenTc;
using static TcHaxx.Extensions.v1.TchaxxExtensionsExtensions;

var extensionRegistry = ExtensionRegistryBuilder.Build();

var response = new CodeGeneratorResponse();
var request = CodeGeneratorRequest.Parser
    .WithExtensionRegistry(extensionRegistry)
    .ParseFrom(Console.OpenStandardInput());

foreach (var file in request.ProtoFile)
{
    if (file.Name.Equals("google/protobuf/descriptor.proto"))
    {
        continue;
    }

    foreach (var message in file.MessageType)
    {
        var responseFile = new CodeGeneratorResponse.Types.File
        {
            Name = message.Name + ".TcPou",
            Content = "// This file was generated by a tool.\n"
        };
        response.File.Add(responseFile);

        foreach (var field in message.Field)
        {
            await Console.Error.WriteLineAsync($"Field: {field.Name} (Type: {field.Type})");

#pragma warning disable IDE0072 // Add missing cases
            responseFile.Content += field.Type switch
            {
                FieldDescriptorProto.Types.Type.String => ProcessStringField(field),
                // FieldDescriptorProto.Types.Type.Double => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Float => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Int64 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Uint64 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Int32 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Fixed64 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Fixed32 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Bool => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Group => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Message => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Bytes => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Uint32 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Enum => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Sfixed32 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Sfixed64 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Sint32 => throw new NotImplementedException(),
                // FieldDescriptorProto.Types.Type.Sint64 => throw new NotImplementedException(),
                _ => ProcessUnknownField(field),
            };
#pragma warning restore IDE0072 // Add missing cases
        }
    }
    response.WriteTo(Console.OpenStandardOutput());
}
static string ProcessStringField(FieldDescriptorProto field)
{
    var sb = new StringBuilder();

    var options = field.Options;
    if (options is null)
    {
        sb.Append($"{field.Name} : STRING;");
    }
    else
    {
        if (options.HasExtension(MaxStringLen))
        {
            var extensionValue = options.GetExtension(MaxStringLen);
            sb.Append($"{field.Name} : STRING({extensionValue});");
        }
    }

    sb.AppendLine();
    return sb.ToString();
}

static string ProcessUnknownField(FieldDescriptorProto field)
{
    Console.Error.WriteLine($"Unhandled field type: {field.Type}");
    return $"// Unknown field type: {field.Type}";
}
